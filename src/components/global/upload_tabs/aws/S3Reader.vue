<template>
  <v-stepper v-model="step" vertical class="elevation-0">
    <v-stepper-step :complete="!!assumed_role" step="1">
      Account Credentials
    </v-stepper-step>

    <AuthStepBasic
      v-bind:access_token.sync="access_token"
      v-bind:secret_token.sync="secret_token"
      @auth-basic="handle_basic"
      @goto-mfa="handle_goto_mfa"
    />

    <v-stepper-step
      :complete="!!assumed_role && assumed_role.from_mfa"
      step="2"
    >
      MFA Authorization
    </v-stepper-step>

    <AuthStepMFA
      v-bind:mfa_token.sync="mfa_token"
      v-bind:mfa_serial.sync="mfa_serial"
      @auth-mfa="handle_proceed_mfa"
      @exit-mfa="handle_cancel_mfa"
    />

    <v-stepper-step step="3">
      Browse Bucket
    </v-stepper-step>

    <FileList
      :auth="assumed_role"
      :files="files"
      @exit-list="handle_cancel_mfa"
      @got-files="got_files"
      @load-bucket="load_bucket"
    />
  </v-stepper>
</template>

<script lang="ts">
import Vue from 'vue';
import Component from 'vue-class-component';
import {getModule} from 'vuex-module-decorators';
import S3, {ObjectKey} from 'aws-sdk/clients/s3';
import {AWSError} from 'aws-sdk/lib/error';
import {LocalStorageVal} from '../../../../utilities/helper_util';
import FileList from '@/components/global/upload_tabs/aws/FileList.vue';
import AuthStepMFA from '@/components/global/upload_tabs/aws/AuthStepMFA.vue';
import AuthStepBasic from '@/components/global/upload_tabs/aws/AuthStepBasic.vue';
import {
  Auth,
  transcribe_error,
  get_session_token,
  MFA_Info,
  AUTH_DURATION
} from '../../../../utilities/aws_util';
import InspecIntakeModule, {FileID} from '@/store/report_intake';

// We declare the props separately to make props types inferable.
const Props = Vue.extend({
  props: {}
});

/** The cached session info */
const local_session_information = new LocalStorageVal<Auth | null>(
  'aws_session_info'
);

/**
 * File reader component for taking in inspec JSON data.
 * Uploads data to the store with unique IDs asynchronously as soon as data is entered.
 * Emits "got-files" with a list of the unique_ids of the loaded files.
 */
@Component({
  components: {
    AuthStepBasic,
    AuthStepMFA,
    FileList
  }
})
export default class S3Reader extends Props {
  /** Form required field rules. Maybe eventually expand to other stuff */
  req_rule = (v: string | null | undefined) =>
    (v || '').trim().length > 0 || 'Field is Required';

  /** Passed from step 1 to step 2 (MFA) if necessary */
  /** State of all globally relevant fields */
  access_token: string = '';
  secret_token: string = '';
  mfa_serial: string = '';
  mfa_token: string = '';

  /** Our session information, generated by AWS STS */
  assumed_role: Auth | null = null;

  /** Current step */
  step: number = 1;

  /** Currently loaded file list from bucket */
  files: S3.Object[] = [];

  /**
   * Logs out of current auth stage
   */
  logout() {
    this.assumed_role = null;
    this.mfa_token = '';
  }

  /**
   * Handle a basic login.
   * Gets a session token
   */
  handle_basic() {
    // Attempt to assume role based on if we've determined 2fa necessary
    get_session_token(this.access_token, this.secret_token, AUTH_DURATION).then(
      // Success of get session token - now need to determine if MFA necessary
      success => {
        this.assumed_role = success;
        this.step = 3;
      },

      // Failure of initial get session token: want to set error normally
      failure => {
        this.handle_error(failure);
      }
    );
  }

  /** If the user tries to login by going to MFA, first check that the account is valid */
  handle_goto_mfa() {
    // Attempt to assume role based on if we've determined 2fa necessary
    // Don't need the duration to be very long
    get_session_token(this.access_token, this.secret_token, 10).then(
      // Success of get session token - now need to determine if MFA necessary
      success => {
        this.step = 2;
      },

      // Failure of initial get session token: want to set error normally
      failure => {
        this.handle_error(failure);
      }
    );
  }

  handle_cancel_mfa() {
    this.step = 1;
    this.mfa_token = '';
    this.assumed_role = null; // Just in case
  }

  handle_exit_list() {
    this.step = 1;
    this.mfa_token = '';
    this.assumed_role = null;
    this.files = []; // Just in case
  }

  /** Handle an MFA login.
   * Determine whether further action is necessary
   */
  handle_proceed_mfa() {
    // Build our mfa params
    let mfa: MFA_Info = {
      SerialNumber: this.mfa_serial || null,
      TokenCode: this.mfa_token
    };

    // Attempt to assume role based on if we've determined 2fa necessary
    get_session_token(
      this.access_token,
      this.secret_token,
      AUTH_DURATION,
      mfa
    ).then(
      success => {
        // Keep them
        this.assumed_role = success;
        this.step = 3;
      },
      failure => {
        this.handle_error(failure);
      }
    );
  }

  /** On mount, try to look up stored auth info */
  mounted() {
    // Load our session, if there is one
    this.assumed_role = local_session_information.get_default(null);
    if (this.assumed_role) {
      this.step = 3;
    }
  }

  /** Attempt to load.
   * Basically just wraps fetch_files with error handling
   */
  async load_bucket(name: string) {
    let s3 = new S3(this.assumed_role!.creds);
    await s3
      .listObjectsV2({
        Bucket: name,
        MaxKeys: 100
      })
      .promise()
      .then(success => {
        this.files = success.Contents || [];
      })
      .catch(failure => this.handle_error(failure));
  }

  /** Save the current credentials to local storage */
  save_creds() {
    local_session_information.set(this.assumed_role);
  }

  /** Callback to handle an AWS error.
   * Sets shown error.
   */
  handle_error(error: any): void {
    let t_error = error as AWSError;
    let formatted_error = transcribe_error(t_error);
    // Toast whatever error we got
    this.$toasted.global.error({
      message: formatted_error,
      isDark: this.$vuetify.theme.dark
    });
  }

  /** Callback on got files */
  got_files(files: Array<FileID>) {
    this.$emit('got-files', files);
  }
}
</script>
